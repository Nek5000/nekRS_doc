.. _postprocessing:

Postprocessing
==============

**TODO**

Once a case has been setup correctly so it can be run without errors, you may want 
to modify the postprocessing to of the simulation output. By default, NekRS will
output a basic set of data according to frequency set in the ``writeInterval`` of
the :ref:`par_file` which can subsequently be viewed through a visualization
tool such as Paraview or Visit. However, additional data or derived values can
be extracted by setting up User Defined outputs using the ``UDF_ExecuteStep``
function of the ``.udf`` file.

.. _checkpointing_visualisation:

Checkpointing & Visualization
-----------------------------

**TODO**

Standard NekRS field data output files have the form ``<case>0.f<n>``, where ``<case>`` is the
case name and ``<n>`` is a five-digit number indicating the number of the output
file (each output file represents a single time step that is output according to
the settings for ``writeControl`` and ``writeInterval`` in the ``.par`` file).
These output files are in a custom binary format that requires a ``<case>.nek5000``
file to be viewable in Paraview (or similar tools). This should be automatically
generated by NekRS, but can also be manually created using the ``nrsvis`` script.

.. _compute_derived:

Compute Derived Quantity
------------------------

**TODO**

Additional control of the simulation to compute additional/derived quantities 
or output custom fields can be achieved by utilising the ``UDF_ExecuteStep`` 
function of the ``.udf`` file. Here we demonstrate how this can be used to 
compute a derived quantity and output custom fields.

Qcriterion in turbPipe example

.. _custom_checkpoint:

Adding Custom Checkpoint Fields
-------------------------------

.. code-block:: cpp
    
    nrs->addUserCheckpointField("scalar01", std::vector<deviceMemory<dfloat>>{o_nuAVM});

Adding Custom Output File
-------------------------

**TODO**

.. code-block:: cpp

    iofld = iofldFactory::create();
    iofld->open(mesh, iofld::mode::write, "qcrit");
    iofld->writeAttribute("uniform", "true");
    iofld->writeAttribute("polynomialOrder", std::to_string(mesh->N + 2));
    iofld->process();

.. _turbulence_stats:

Run-time Averaging
------------------

Legacy Averaging Method
^^^^^^^^^^^^^^^^^^^^^^^^

When running a high fidelity case with DNS or LES turbulence models, it is often necessary to time-average the solution fields to extract meaningful quantities.
This may sometimes even be useful for a RANS case as well.
*NekRS* provides in-built routines that can be embedded in :ref:`udf_file` to do run-time averaging and write relevant field files. 
These are included in ``tavg`` plugin and made available in ``udf`` file by including the ``tavg.hpp`` header file at the top of ``.udf``.
The minimal structure in ``.udf`` for performing time averaging is as follows:

.. code-block:: c++

   #include "tavg.hpp"

   std::unique_ptr<nrs_t::tavgLegacy_t> avg;

   void UDF_Setup()
   {
      avg = std::make_unique<nrs_t::tavgLegacy_t>();
   }

   void UDF_ExecuteStep(double time, int tstep)
   {
      auto mesh = nrs->meshV;

      if(nrs->timeStepConverged) avg->run(time);

      if(nrs->checkPointStep) {
      //if(nrs->lastStep) {
        avg->writeToFile(mesh);
        avg->reset();
      }
   }

The above code is equivalent to the legacy averaging routines in `Nek5000 <https://nek5000.github.io/NekDoc/problem_setup/features.html#averaging>`_.
It computes run-time average of all primitive variables, i.e., :math:`u`, :math:`v`, :math:`w`, and :math:`T`, as well as the second order terms :math:`u^2`, :math:`v^2`, :math:`w^2`, :math:`T^2`, :math:`uv`, :math:`uw`, and :math:`vw`.
These fields can be subsequently used to reconstruct Reynolds stress.
``avg`` is a pointer to the ``tavgLegacy_t`` object, which contains internal logic to perform time averaging. 
``std::unique_ptr<>`` is a smart pointer from the C++11 standard library that automatically manages the dynamically allocated object ``avg``. 
In ``UDF_Setup`` the ``std::make_unique`` constructs the ``tavgLegacy_t`` object and returns and assigns a ``unique_ptr`` to ``avg``.
Run-time averaging is executed with the ``avg->run()`` call in ``UDF_ExecuteStep``.
It passes an argument ``time`` to record the current simulation time while averaging.
Note that it is important to call ``avg->run()`` within an if condition block, qualified by ``nrs->timeStepConverged`` call to ensure averaging is only performed after all inner iterations for the current time step have converged.
The averaged fields are written to the disk using `avg->writeTofile`` call made within an if block qualified with ``nrs->checkPointStep`` condition. 
The user may also choose to only write the field files at the final simulation time step, in which case the ``nrs->lastStep`` condition should be used.
``avg->writeToFile`` writes three checkpoint files ``avg0.fXXXXX``, ``rms0.fXXXXX`` and ``rm20.fXXXXX``. 
The time-window for averaging is reset using the ``avg->reset()`` call.
This call clears the internal averaging arrays and restarts averaging from the ``nrs->checkPointStep``.
The complete list of variables, including which file they are written to and the scalar position they occupy in that file are specified in the table below.
Additionally, the width of the time-window is recorded as the physical time in each average file

.. csv-table:: Variables included in Legacy *NekRS* average field files
   :header: "Variable","filename","scalar position"
   :widths: 10, 30, 30

   :math:`\overline{u}`,avg0.fXXXXX,u-velocity
   :math:`\overline{v}`,avg0.fXXXXX,v-velocity
   :math:`\overline{w}`,avg0.fXXXXX,w-velocity
   :math:`\overline{T}`,avg0.fXXXXX,temperature
   :math:`\overline{\phi_i}`,avg0.fXXXXX,scalar i
   :math:`\overline{u^2}`,rms0.fXXXXX,u-velocity
   :math:`\overline{v^2}`,rms0.fXXXXX,v-velocity
   :math:`\overline{w^2}`,rms0.fXXXXX,w-velocity
   :math:`\overline{T^2}`,rms0.fXXXXX,temperature
   :math:`\overline{\phi_i^2}`,rms0.fXXXXX,scalar i
   :math:`\overline{uv}`,rm20.fXXXXX,u-velocity
   :math:`\overline{vw}`,rm20.fXXXXX,v-velocity
   :math:`\overline{uw}`,rm20.fXXXXX,w-velocity

Custom Averaging
^^^^^^^^^^^^^^^^^^^^^^^^^^

*NekRS* provides the user the option of performing run-time averaging of custom fields.
These must be defined in the ``UDF_Setup()`` routine.
The following code block shows a template example for defining custom averaging in ``.udf`` file:

.. code-block::

   #include "tavg.hpp"

   std::unique_ptr<tavg> avg;

   void UDF_Setup()
   {
      std::vector< tavg::field > tavgFields;

      deviceMemory<dfloat> o_u(nrs->scalar->o_U.slice(0 * nrs->fieldOffset , nrs->fieldOffset));
      deviceMemory<dfloat> o_v(nrs->scalar->o_U.slice(1 * nrs->fieldOffset , nrs->fieldOffset));
      auto idx = nrs->scalar->nameToIndex.find("temperature")->second;
      deviceMemory<dfloat> o_temp(nrs->scalar->o_S.slice(nrs->scalar->fieldOffsetScan[idx], nrs->scalar->fieldOffset()));

      tavgFields.push_back({"ux", std::vector{o_u}});
      tavgFields.push_back({"uy", std::vector{o_v}});
      tavgFields.push_back({"T", std::vector{o_temp}});

      tavgFields.push_back({"uxux", std::vector{o_u, o_u}});
      tavgFields.push_back({"uyuy", std::vector{o_v, o_v}});
      tavgFields.push_back({"uxuxT", std::vector{o_u, o_u, o_temp}});

      avg = std::make_unique<tavg>(nrs->fluid->fieldOffset, tavgFields);
   }

   void UDF_ExecuteStep(double time, int tstep)
   {
      auto mesh = nrs->meshV;

      if(nrs->timeStepConverged) avg->run(time);

      if(nrs->checkPointStep) {
        avg->writeToFile(mesh);
        // avg->writeToFile(mesh, false); (not recommended)
      }
   }

To create custom averaging fields declare a global ``unique_ptr``, ``avg``, to the ``<tavg>`` object at the top of ``.udf`` file.
In ``UDF_Setup()`` the user can then define the fields that one wants to compute averages for.
As shown, the fields are added to a ``std::vector`` container of type ``tavg::field``, ``tavgFields``.
``o_u``, ``o_v`` and ``o_temp`` are pointers that reference specific fields, x-velocity, y-velocity and temperature, respectively.
These are then added to ``tavgFields`` container using the ``tavgFields.push_back()`` function.
It takes two arguments, user defined field name, e.g., ``"ux"``, and ``std::vector`` type field container constructed using the corresponding field :term:`OCCA` array. 
Note that the user can identify the scalar index of temperature field with ``nrs->scalar->nameToIndex.find("temperature")->second`` call.
The user can also create composite fields, such as ``"uxux"``, ``"uyuy"`` and ``"uxuxT"``, as shown above which will compute average of :math:`u^2`, :math:`v^2` and :math:`u^2T`, respectively.
Finally, ``make_unique`` constructs the ``<tavg>`` object for time averaging.
It takes two arguments, viz., the offset or size of fields, ``nrs->fluid->fieldOffset`` and the accumulated ``tavgFields`` container comprising all user defined fields to be averaged.

The run time averaging operation is performed in ``UDF_ExecuteStep`` routine with the ``avg->run`` call.
To print the field files to the disk, ``avg->writeToFile`` is called within the if block with condition ``nrs->checkPointStep``.
Note that this call automatically resets the time averaging window.
If for some reason the user does not want to reset time averaging window, a second ``bool`` argument may be passed to ``avg->writeToFile`` to explicitly turn off resetting (not recommended).
``avg->writeToFile`` will write field file ``tavg0.fXXXXX`` to disk which only has scalar fields.
Corresponding to above example the variables written to field file and their scalar positions are:

.. csv-table:: Variables included in custom *NekRS* average field file ``tavg0.fXXXXX``
   :header: "Variable","scalar position"
   :widths: 50, 50

   :math:`\overline{ux}`,scalar 1
   :math:`\overline{uy}`,scalar 2
   :math:`\overline{T}`,scalar 3
   :math:`\overline{uxux}`,scalar 4
   :math:`\overline{uyuy}`,scalar 5
   :math:`\overline{uxuxT}`,scalar 6
